<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Connery's Interrail Chaos: Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Press Start 2P', sans-serif;
            color: white;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas { display: block; }

        /* UI OVERLAYS */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            display: flex; justify-content: space-between; width: 100%;
            text-shadow: 2px 2px 0 #000; font-size: 14px;
        }

        .health-bar-container {
            width: 200px; height: 20px; background: #333;
            border: 2px solid #fff; margin-top: 5px;
        }

        #hp-fill { width: 100%; height: 100%; background: #e74c3c; transition: width 0.1s; }
        
        #boss-hp-container {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 30px; background: #220022; border: 3px solid #dcdcdc; display: none;
        }
        
        #boss-hp-fill { width: 100%; height: 100%; background: #a020f0; transition: width 0.2s; }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all; text-align: center;
        }
        .hidden { display: none !important; }

        h1 { color: #55ff55; text-shadow: 4px 4px 0 #000; font-size: 2rem; line-height: 1.5; margin-bottom: 20px;}
        h2 { color: #f1c40f; margin-bottom: 10px; font-size: 1.2rem; }
        p { color: #ddd; font-size: 10px; line-height: 1.8; max-width: 600px; margin-bottom: 20px; }
        button {
            background: #3498db; color: #fff; border: 4px solid #fff; padding: 15px 25px;
            font-family: 'Press Start 2P'; font-size: 0.9rem; cursor: pointer; transition: 0.2s; margin: 10px;
        }
        button:hover { transform: scale(1.1); background: #2980b9; }

        .level-btn { background: #8e44ad; font-size: 0.7rem; padding: 10px; width: 250px; }

        /* DIALOGUE BOX */
        #dialogue-box {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 80%; background: rgba(0,0,0,0.9); border: 4px solid #fff; padding: 20px;
            z-index: 50; display: none; text-align: left;
        }
        #dialogue-name { color: #f1c40f; margin-bottom: 10px; font-size: 12px; }
        #dialogue-text { color: #fff; font-size: 12px; line-height: 1.5; }
        #dialogue-hint { text-align: right; font-size: 8px; color: #888; margin-top: 10px; }

        /* POPUP NOTIFICATION */
        #popup-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 2px solid #f1c40f; color: #f1c40f;
            padding: 10px 20px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.5s;
        }

        /* MOBILE JOYSTICK */
        #joystick-zone {
            position: absolute; width: 150px; height: 150px;
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1); display: none; pointer-events: none;
        }
        #joystick-knob {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.5); left: 45px; top: 45px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <div id="score">SCORE: 0</div>
                <div class="health-bar-container"><div id="hp-fill"></div></div>
            </div>
            <div style="text-align: right;">
                <div id="location-text">MUNICH</div>
                <div id="objective-text">SURVIVE</div>
                <div id="wave-text" style="color: #f1c40f; margin-top: 5px;"></div>
            </div>
        </div>
        <div id="boss-hp-container"><div id="boss-hp-fill"></div></div>
        <div id="popup-msg">GUN UPGRADED!</div>
        <!-- Joystick Overlay -->
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen">
        <h1>CONNERY'S<br>INTERRAIL CHAOS</h1>
        <p>Happy 20th Birthday!</p>
        <p>5 Levels. 1 Bullet Hell Boss. 1 Waifu.</p>
        <div class="btn-group">
            <button onclick="startGame('STORY')">STORY MODE</button>
            <button onclick="startGame('ARCADE')">ARCADE MODE</button>
        </div>
        <p style="margin-top:30px; font-size: 8px; color: #777;">Controls: WASD / Arrows to Move</p>
    </div>

    <!-- LEVEL SELECT SCREEN (SECRET) -->
    <div id="level-select-screen" class="screen hidden">
        <h2 style="color: #f1c40f;">SECRET LEVEL SELECT</h2>
        <button class="level-btn" onclick="startLevel(1)">1. Munich</button>
        <button class="level-btn" onclick="startLevel(2)">2. Train</button>
        <button class="level-btn" onclick="startLevel(3)">3. Hospital</button>
        <button class="level-btn" onclick="startLevel(4)">4. Prague</button>
        <button class="level-btn" onclick="startLevel(5)">5. BOSS</button>
        <button class="level-btn" onclick="startLevel(6)">6. Ending</button>
        <button style="margin-top: 20px;" onclick="location.reload()">BACK</button>
    </div>

    <!-- UPGRADE SCREEN -->
    <div id="upgrade-screen" class="screen hidden">
        <h2>WAVE COMPLETE!</h2>
        <p>Choose an upgrade:</p>
        <button onclick="applyUpgrade('speed')">Speed +</button>
        <button onclick="applyUpgrade('damage')">Dmg +</button>
        <button onclick="applyUpgrade('heal')">Heal Full</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff5555;">WASTED</h1>
        <p id="death-reason">You died.</p>
        <p id="final-score-disp">Score: 0</p>
        <button onclick="location.reload()">TRY AGAIN</button>
    </div>

    <!-- VICTORY SCREEN -->
    <div id="victory-screen" class="screen hidden">
        <h1 style="color: #f1c40f;">HAPPY 20th BIRTHDAY!</h1>
        <div style="font-size: 40px; margin: 20px;">üéÇ</div>
        <p>You saved Hu Tao!</p>
        <p>Love from the boys:<br>Bakshi, Rishi, Ibby, Sean, Samir, Sebastian</p>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <!-- DIALOGUE -->
    <div id="dialogue-box">
        <div id="dialogue-name">BAKSHI</div>
        <div id="dialogue-text">...</div>
        <div id="dialogue-hint">PRESS SPACE OR TAP TO CONTINUE</div>
    </div>
</div>

<script>
// --- ASSETS ---
const IMAGES = { hutao: new Image(), kiss: new Image() };
IMAGES.hutao.src = "https://www.pngall.com/wp-content/uploads/14/Hu-Tao-PNG-Free-Image.png";
IMAGES.kiss.src = "https://cdn.discordapp.com/attachments/426860684500795394/1448133776633892915/ConneryTao.png?ex=693a272d&is=6938d5ad&hm=9774114f7e4cc7155f45a98c106e83d85791364b99834ca8b89ee282e85e38a1&";

/** AUDIO SYSTEM */
const AudioSys = {
    ctx: null, isPlaying: false, currentTrack: 'normal',
    
    melody: ['E4','E4','G4','A4','C5','A4','G4', 'G4','A4','G4','E4','D4','E4', 'G4','G4','E4','D4','C4','A3','C4', 'D4','E4','G4','E4','D4','C4'],
    
    bossMelody: [
        'C3','C3','C3','Eb3','D3','C3','B2','G2', 'C3','C3','C3','F3','Eb3','D3','C3','G2',
        'Ab2','Ab2','G2','F2','G2','Ab2','Bb2','B2', 'C3','D3','Eb3','F3','G3','F3','Eb3','D3',
        'C2','C2','C3','C3','Eb3','D3','C3','B2', 'G2','G2','B2','B2','D3','C3','B2','G2'
    ],
    
    noteFreqs: {
        'F2':87, 'G2':98, 'Ab2':103, 'A2':110, 'Bb2':116, 'B2':123, 'C3':130, 'D3':146, 'Eb3':155, 'E3':164, 'F3':174, 'G3':196,
        'A3':220, 'C4':261, 'D4':293, 'E4':329, 'G4':392, 'A4':440, 'C5':523, 'D5':587
    },
    
    init() { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); },
    
    playTone(freq, type='sine', duration=0.1, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },

    playBGM(isBoss = false) {
        if(!this.ctx) return;
        if(this.isPlaying && this.currentTrack !== (isBoss ? 'boss' : 'normal')) {
            this.isPlaying = false; setTimeout(() => this.startLoop(isBoss), 200); return;
        }
        if(!this.isPlaying) this.startLoop(isBoss);
    },

    startLoop(isBoss) {
        this.isPlaying = true; this.currentTrack = isBoss ? 'boss' : 'normal';
        let noteIdx = 0; const track = isBoss ? this.bossMelody : this.melody;
        const speed = isBoss ? 160 : 600;

        const loop = () => {
            if(!this.isPlaying || (isBoss && this.currentTrack !== 'boss') || (!isBoss && this.currentTrack !== 'normal')) return;
            const note = track[noteIdx];
            const freq = this.noteFreqs[note] || 200;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = isBoss ? 'sawtooth' : 'triangle';
            osc.frequency.value = freq;
            let vol = isBoss ? 0.15 : 0.05;
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + (speed/1000));
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + (speed/1000) + 0.1);
            
            noteIdx = (noteIdx + 1) % track.length;
            setTimeout(loop, speed);
        };
        loop();
    },

    stopBGM() { this.isPlaying = false; },
    sfxThrow() { this.playTone(400, 'square', 0.1, 0.05); },
    sfxHit() { this.playTone(100, 'sawtooth', 0.2, 0.1); },
    sfxExplode() { this.playTone(60, 'sawtooth', 0.5, 0.3); },
    sfxHeal() { this.playTone(800, 'sine', 0.3, 0.1); this.playTone(1200, 'sine', 0.3, 0.1); },
    sfxBossRoar() { this.playTone(50, 'sawtooth', 1.0, 0.4); }
};

/** GAME ENGINE */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = 'MENU'; let gameMode = 'ARCADE'; let level = 1; let enemiesKilled = 0; let score = 0;
let arcadeWave = 1; let timeElapsed = 0; let lastTime = 0;
const ARCADE_LIMIT = 1500; const MAP_SIZE = 2500;

// Inputs & Cheats
let cheatBuffer = "";
const keys = { w:false, a:false, s:false, d:false };

window.addEventListener('keydown', e => {
    // Cheat Code
    cheatBuffer += e.key.toLowerCase();
    if(cheatBuffer.length > 8) cheatBuffer = cheatBuffer.slice(-8);
    if(cheatBuffer === "goalpost" && gameState === 'MENU') {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('level-select-screen').classList.remove('hidden');
    }

    if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
    if(e.key === ' ' && gameState === 'PAUSE_DIALOGUE') advanceDialogue();
});
window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
window.addEventListener('mousedown', () => { if(gameState === 'PAUSE_DIALOGUE') advanceDialogue(); });

// MOBILE TOUCH CONTROLS (JOYSTICK)
let touchStart = null;
const joyZone = document.getElementById('joystick-zone');
const joyKnob = document.getElementById('joystick-knob');

window.addEventListener('touchstart', e => {
    if(gameState === 'PAUSE_DIALOGUE') { advanceDialogue(); return; }
    
    // Show Joystick
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    joyZone.style.display = 'block';
    joyZone.style.left = (touchStart.x - 75) + 'px';
    joyZone.style.top = (touchStart.y - 75) + 'px';
    joyKnob.style.left = '45px'; joyKnob.style.top = '45px';
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault(); if(!touchStart) return;
    
    const cx = e.touches[0].clientX; const cy = e.touches[0].clientY;
    const dx = cx - touchStart.x; const dy = cy - touchStart.y;
    
    // Move Knob Visual
    const dist = Math.min(Math.hypot(dx, dy), 75);
    const angle = Math.atan2(dy, dx);
    const kx = Math.cos(angle) * dist; const ky = Math.sin(angle) * dist;
    joyKnob.style.left = (45 + kx) + 'px';
    joyKnob.style.top = (45 + ky) + 'px';

    // 8-Directional Logic
    keys.w = keys.s = keys.a = keys.d = false;
    const threshold = 20;
    
    if (dist > threshold) {
        // Convert angle to octants
        const deg = angle * (180/Math.PI);
        
        // Right
        if (deg > -22.5 && deg <= 22.5) { keys.d = true; }
        // Bottom-Right
        else if (deg > 22.5 && deg <= 67.5) { keys.d = true; keys.s = true; }
        // Bottom
        else if (deg > 67.5 && deg <= 112.5) { keys.s = true; }
        // Bottom-Left
        else if (deg > 112.5 && deg <= 157.5) { keys.s = true; keys.a = true; }
        // Left
        else if (Math.abs(deg) > 157.5) { keys.a = true; }
        // Top-Left
        else if (deg < -112.5 && deg >= -157.5) { keys.a = true; keys.w = true; }
        // Top
        else if (deg < -67.5 && deg >= -112.5) { keys.w = true; }
        // Top-Right
        else if (deg < -22.5 && deg >= -67.5) { keys.w = true; keys.d = true; }
    }

}, {passive: false});

window.addEventListener('touchend', () => { 
    keys.w = keys.s = keys.a = keys.d = false; 
    touchStart = null;
    joyZone.style.display = 'none';
});

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

// --- ENTITIES ---
class Entity {
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.markedForDeletion = false;
    }
}

class Particle {
    constructor(x, y, color, speedScale = 1) {
        this.x = x; this.y = y; this.color = color;
        const a = Math.random() * Math.PI * 2; 
        const s = (Math.random() * 100 + 50) * speedScale;
        this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
        this.life = 0.8; this.size = Math.random() * 4 + 2;
    }
    update(dt) {
        this.x += this.vx * dt; this.y += this.vy * dt;
        this.life -= dt; this.size *= 0.95;
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1;
    }
}

class Player {
    constructor() {
        this.x = 0; this.y = 0; this.radius = 16;
        this.speed = 280; this.hp = 125; this.maxHp = 125;
        this.diceTimer = 0; this.swordAngle = 0; this.dmgMult = 1;
        this.doubleShot = false;
    }
    update(dt, walls) {
        let dx = 0, dy = 0;
        if(keys.w) dy = -1; if(keys.s) dy = 1; if(keys.a) dx = -1; if(keys.d) dx = 1;
        if(dx !== 0 || dy !== 0) { const len = Math.hypot(dx, dy); dx /= len; dy /= len; }
        let nx = this.x + dx * this.speed * dt; let ny = this.y + dy * this.speed * dt;
        if(!checkWallCollision(nx, this.y, this.radius, walls)) this.x = nx;
        if(!checkWallCollision(this.x, ny, this.radius, walls)) this.y = ny;

        if(gameMode === 'ARCADE' || level === 5) { 
            const limit = level === 5 ? 900 : ARCADE_LIMIT;
            this.x = Math.max(-limit, Math.min(limit, this.x));
            this.y = Math.max(-limit, Math.min(limit, this.y));
        }

        this.swordAngle += 6 * dt; this.diceTimer += dt;
        let fireRate = level === 5 ? 0.2 : 0.6; 
        if(this.diceTimer > fireRate) { this.diceTimer = 0; shootDice(); }
    }
    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(this.x, this.y+12, 12, 6, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#44bd32'; ctx.fillRect(this.x-14, this.y-14, 28, 28);
        ctx.fillStyle = 'black'; ctx.fillRect(this.x-8, this.y-6, 4, 4); ctx.fillRect(this.x+4, this.y-6, 4, 4); ctx.fillRect(this.x-4, this.y+4, 8, 2);
        ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(this.x-10, this.y-14); ctx.lineTo(this.x+10, this.y-14); ctx.lineTo(this.x, this.y-35); ctx.fill();
        
        const sx = this.x + Math.cos(this.swordAngle) * 70; const sy = this.y + Math.sin(this.swordAngle) * 70;
        ctx.save(); ctx.translate(sx, sy); ctx.rotate(this.swordAngle + Math.PI/4);
        ctx.fillStyle = '#00ffff'; ctx.fillRect(-4, -20, 8, 40); ctx.fillStyle = '#8B4513'; ctx.fillRect(-8, 15, 16, 4); ctx.fillRect(-3, 19, 6, 10);
        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(type, x, y) {
        super(x, y, 20); this.type = type; this.pushX = 0; this.pushY = 0;
        
        // UPDATED STATS
        if(type === 'WOBBUFFET') { this.maxHp = 30; this.speed = 110; this.damage = 1.5; } 
        else if (type === 'APPLE') { this.maxHp = 25; this.speed = 190; this.damage = 2; } 
        else if (type === 'POLICE') { this.maxHp = 50; this.speed = 130; this.damage = 1.5; }
        else if (type === 'TICKET') { this.maxHp = 25; this.speed = 140; this.damage = 1.5; }
        else if (type === 'ROLL') { this.maxHp = 30; this.speed = 210; this.damage = 5; }
        else if (type === 'CREEPER') { this.maxHp = 25; this.speed = 100; this.damage = 3; } 
        else if (type === 'FIREBALL') { this.maxHp = 1; this.speed = 200; this.radius = 10; this.damage = 15; }
        
        this.hp = this.maxHp;
        if (gameMode === 'ARCADE') {
            this.hp += (arcadeWave * 5); this.speed += (arcadeWave * 3); this.damage += (arcadeWave * 0.5);
        }
    }
    update(dt, player, walls) {
        let angle = Math.atan2(player.y - this.y, player.x - this.x);
        this.pushX *= 0.9; this.pushY *= 0.9;
        if (this.type === 'FIREBALL') { this.pushX = 0; this.pushY = 0; }
        let vx = Math.cos(angle) * this.speed + this.pushX; let vy = Math.sin(angle) * this.speed + this.pushY;
        let nx = this.x + vx * dt; let ny = this.y + vy * dt;
        if(!checkWallCollision(nx, this.y, this.radius, walls)) this.x = nx;
        if(!checkWallCollision(this.x, ny, this.radius, walls)) this.y = ny;
        if(this.type === 'CREEPER') { this.colorFlash = (Math.hypot(player.x-this.x, player.y-this.y) < 100 && (Date.now() % 200 < 100)); }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        if(this.type === 'WOBBUFFET') {
            ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.ellipse(0, 0, 20, 25, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black'; ctx.font = '16px monospace'; ctx.textAlign = 'center'; ctx.fillText(">.<", 0, 5); ctx.fillRect(12, 10, 8, 8);
        } else if (this.type === 'APPLE') {
            ctx.fillStyle = '#4cd137'; ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 2, 12, 0, Math.PI, false); ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-5, 2); ctx.lineTo(-5, 14); ctx.moveTo(5, 2); ctx.lineTo(5, 14); ctx.stroke();
        } else if (this.type === 'CREEPER') {
            ctx.fillStyle = this.colorFlash ? '#fff' : '#00b800'; ctx.fillRect(-15, -25, 30, 50); 
            ctx.fillStyle = 'black'; ctx.fillRect(-5, -15, 10, 10); ctx.fillRect(-10, -20, 5, 5); ctx.fillRect(5, -20, 5, 5); ctx.fillRect(-5, -5, 10, 5);
        } else if (this.type === 'FIREBALL') {
            ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        } else if (this.type === 'ROLL') {
            ctx.fillStyle = '#d35400'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0,0);
            for(let i=0; i<30; i++) { let ang = i * 0.5; let r = i * 0.6; ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r); } ctx.stroke();
        } else {
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(-15,-20,30,40);
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(5, -5, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-10,-25,20,15);
        }
        ctx.restore();
    }
}

class EnderDragon extends Entity {
    constructor() {
        super(0, -600, 80);
        this.hp = 10000; this.maxHp = 10000;
        this.timer = 0; this.phase = 0; this.subPhase = 0;
        this.targetX = 0; this.targetY = -400;
        this.color = '#a020f0';
        this.hasUpgradedPlayer = false;
    }
    update(dt) {
        this.timer += dt;
        this.x += (this.targetX - this.x) * 0.05; this.y += (this.targetY - this.y) * 0.05;

        // Upgrade Check (66% HP remaining)
        if(!this.hasUpgradedPlayer && this.hp < 6600) {
            this.hasUpgradedPlayer = true;
            player.doubleShot = true;
            showPopup("Hu Tao: I upgraded your gun! Double shot active!");
        }

        // --- ATTACK SEQUENCES ---
        // Switch phase every 6 seconds
        if(this.timer > 6.0) {
            this.timer = 0;
            this.phase = (this.phase + 1) % 3;
            this.subPhase = 0;
            AudioSys.sfxBossRoar();
        }

        // Sub-phase logic within the 6s window
        if(this.phase === 0) { 
            // PHASE 1: ORANGE - Tri-Strafe Circle
            this.color = '#e67e22';
            if(Math.floor(this.timer) > this.subPhase) {
                this.subPhase++;
                if(this.subPhase === 1) { this.targetX = 0; this.shootRing(16); }
                if(this.subPhase === 2) { this.targetX = -600; this.shootRing(12); }
                if(this.subPhase === 3) { this.targetX = 600; this.shootRing(12); }
                if(this.subPhase === 4) { this.targetX = 0; this.shootRing(16); }
            }
        } else if (this.phase === 1) {
            // PHASE 2: PURPLE - Void Rain
            this.color = '#8e44ad';
            this.targetX = 0; this.targetY = -500;
            if((this.timer * 10) % 2 < 1 && Math.random()>0.5) { // Frequent drops
                let x = (Math.random()*1600) - 800;
                let fb = new Enemy('FIREBALL', x, -900);
                fb.vx = 0; fb.vy = 400; fb.update = function(dt) { this.x += this.vx*dt; this.y += this.vy*dt; };
                enemies.push(fb);
            }
        } else {
            // PHASE 3: RED - Laser Burst (SLOWER NOW)
            this.color = '#c0392b';
            this.targetX = player.x; this.targetY = player.y - 300;
            if(this.timer % 0.6 < 0.1) { // 0.6s gap (Slower)
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                let fb = new Enemy('FIREBALL', this.x, this.y);
                fb.vx = Math.cos(angle)*400; fb.vy = Math.sin(angle)*400;
                fb.update = function(dt) { this.x += this.vx*dt; this.y += this.vy*dt; };
                enemies.push(fb);
            }
        }
    }
    shootRing(count) {
        for(let i=0; i<count; i++) {
            let angle = (Math.PI * 2 / count) * i;
            let fb = new Enemy('FIREBALL', this.x, this.y);
            fb.vx = Math.cos(angle)*300; fb.vy = Math.sin(angle)*300;
            fb.update = function(dt) { this.x += this.vx*dt; this.y += this.vy*dt; };
            enemies.push(fb);
        }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.fillStyle = 'black'; ctx.fillRect(-60, -40, 120, 80); 
        ctx.fillStyle = this.color; ctx.fillRect(-50, -20, 20, 10); ctx.fillRect(30, -20, 20, 10);
        ctx.fillStyle = '#222';
        let wingFlap = Math.sin(Date.now()/150) * 40;
        ctx.beginPath(); ctx.moveTo(-60, 0); ctx.lineTo(-200, -80 + wingFlap); ctx.lineTo(-80, 50); ctx.fill();
        ctx.beginPath(); ctx.moveTo(60, 0); ctx.lineTo(200, -80 + wingFlap); ctx.lineTo(80, 50); ctx.fill();
        ctx.restore();
    }
}

class Friend extends Entity {
    constructor(name, emoji, x, y) { super(x, y, 20); this.name = name; this.emoji = emoji; this.actionTimer = 0; this.bossHealTimer = 0; }
    update(dt, enemies, player, friends) {
        if(level === 5 && boss) { // Level 5 is BOSS
            // Friends attack boss
            let dx = (boss.x + (Math.random()-0.5)*200) - this.x;
            let dy = (boss.y + 300) - this.y;
            this.x += dx * 0.02; this.y += dy * 0.02;
            
            this.actionTimer += dt;
            if(this.actionTimer > 1.5) {
                this.actionTimer = 0;
                projectiles.push(new Projectile(this.x, this.y, Math.atan2(boss.y-this.y, boss.x-this.x), 'DICE'));
            }

            // SAMIR ULTIMATE HEAL
            if (this.name === 'Samir') {
                this.bossHealTimer += dt;
                if (this.bossHealTimer > 20) {
                    this.bossHealTimer = 0;
                    player.hp = Math.min(125, player.hp + 50);
                    floatingTexts.push(new FloatingText(player.x, player.y - 20, "SLAY QUEEN +50HP", "#ff00ff"));
                    AudioSys.sfxHeal();
                }
            }
            return;
        }

        let sepX = 0, sepY = 0;
        friends.forEach(f => { if(f !== this) { let d = Math.hypot(this.x - f.x, this.y - f.y); if(d < 50) { sepX += (this.x-f.x)/d; sepY += (this.y-f.y)/d; } } });
        let dist = Math.hypot(player.x - this.x, player.y - this.y);
        if(dist > 120) {
            let angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += (Math.cos(angle) * 220 + sepX * 100) * dt;
            this.y += (Math.sin(angle) * 220 + sepY * 100) * dt;
        }
        this.actionTimer += dt;
        
        if(this.name === 'Bakshi' && this.actionTimer > 1.0) {
            this.actionTimer = 0; if(enemies.length) { let e = enemies[Math.floor(Math.random()*enemies.length)]; projectiles.push(new Projectile(this.x, this.y, Math.atan2(e.y-this.y, e.x-this.x), 'BANANA')); }
        } else if(this.name === 'Rishi' && this.actionTimer > 3) {
            this.actionTimer = 0; floatingTexts.push(new FloatingText(this.x, this.y-40, "FULL BOX!", "#f1c40f"));
            enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 250) { e.pushX = (e.x-this.x)*8; e.pushY = (e.y-this.y)*8; } });
        } else if(this.name === 'Samir' && this.actionTimer > 2) {
            this.actionTimer = 0; if(player.hp < 125) { player.hp = Math.min(125, player.hp + 3); floatingTexts.push(new FloatingText(player.x, player.y, "SLAY +3HP", "#ff7979")); }
        } else if(this.name === 'Ibby') {
            enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 80) { e.hp -= 1; e.pushX = (e.x-this.x)*3; e.pushY = (e.y-this.y)*3; } });
        } else if(this.name === 'Sean') {
            enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 150) { e.hp -= 5*dt; e.pushX += (e.x-this.x)*5*dt; e.pushY += (e.y-this.y)*5*dt; } });
        }
    }
    draw(ctx) {
        if(this.name === 'Sean') { ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, 150, 0, Math.PI*2); ctx.stroke(); }
        ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.emoji, this.x, this.y+10);
        ctx.font = '8px "Press Start 2P"'; ctx.fillStyle = 'white'; ctx.fillText(this.name, this.x, this.y-25);
    }
}

class Projectile {
    constructor(x, y, angle, type='DICE') {
        this.x = x; this.y = y; this.vx = Math.cos(angle)*600; this.vy = Math.sin(angle)*600; 
        this.life = 1.0; this.type = type; this.roll = Math.floor(Math.random()*6)+1;
    }
    update(dt) { this.x += this.vx*dt; this.y += this.vy*dt; this.life -= dt; }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        if(this.type === 'DICE') { ctx.fillStyle = '#fff'; ctx.fillRect(-8,-8,16,16); ctx.fillStyle = 'red'; ctx.font='10px Arial'; ctx.textAlign='center'; ctx.fillText(this.roll, 0, 4); }
        else if (this.type === 'BANANA') { ctx.font = '20px Arial'; ctx.fillText('üçå', -5, 5); }
        ctx.restore();
    }
}

class Pickup extends Entity {
    constructor(x, y) { super(x, y, 15); this.bob = 0; }
    update(dt) { this.bob += dt*5; }
    draw(ctx) {
        const yOff = Math.sin(this.bob)*5;
        ctx.save(); ctx.translate(this.x - 15, this.y - 10 + yOff);
        ctx.fillStyle = '#de2910'; ctx.fillRect(0, 0, 30, 20);
        ctx.fillStyle = '#ffde00'; ctx.beginPath(); ctx.arc(5, 5, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(10, 2, 1, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
}

class FloatingText {
    constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 1.0; this.vy = -40; }
    update(dt) { this.y += this.vy*dt; this.life -= dt * 1.5; }
    draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.font = '10px "Press Start 2P"'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; }
}

// --- GLOBALS ---
let player; let enemies = []; let projectiles = []; let friends = []; let pickups = []; let floatingTexts = []; let particles = []; let walls = []; let dialogueQueue = [];
let boss = null; let endingTimer = 0; let endingPhase = 0; 
let bossIntroState = 0; let bossIntroTimer = 0; let cutsceneHuTao = null;

function checkWallCollision(x, y, r, walls) { for(let w of walls) { if (x > w.x && x < w.x + w.w && y > w.y && y < w.y + w.h) return true; } return false; }

function shootDice() {
    let target = null, minD = 900;
    if(level === 5 && boss) target = boss;
    else enemies.forEach(e => { let d = Math.hypot(e.x - player.x, e.y - player.y); if(d < minD) { minD = d; target = e; } });

    let ang = target ? Math.atan2(target.y - player.y, target.x - player.x) : -Math.PI/2;
    projectiles.push(new Projectile(player.x, player.y, ang, 'DICE'));
    if(player.doubleShot) {
        projectiles.push(new Projectile(player.x + 10, player.y, ang + 0.1, 'DICE'));
    }
    AudioSys.sfxThrow();
    createParticle(player.x, player.y, '#fff', 5);
}

function spawnEnemy() {
    if(level >= 5) return;
    let angle = Math.random() * Math.PI * 2; let dist = 600;
    let x = player.x + Math.cos(angle)*dist; let y = player.y + Math.sin(angle)*dist;

    if(gameMode === 'ARCADE') {
        let r = Math.random(); let type = 'WOBBUFFET';
        if(arcadeWave > 1 && r > 0.5) type = 'APPLE'; if(arcadeWave > 2 && r > 0.7) type = 'POLICE';
        if(arcadeWave > 3 && r > 0.8) type = 'CREEPER'; if(arcadeWave > 4 && r > 0.9) type = 'ROLL';
        enemies.push(new Enemy(type, x, y)); return;
    }
    let type = 'WOBBUFFET';
    if(level === 2) type = Math.random()>0.7?'CREEPER':'TICKET';
    else if(level === 3) type = 'ROLL'; else if(level === 4) type = 'APPLE';
    enemies.push(new Enemy(type, x, y));
}

function generateMap() {
    walls = []; if(level >= 5) return; 
    for(let i=0; i<40; i++) { let x = (Math.random()*MAP_SIZE*2)-MAP_SIZE; let y = (Math.random()*MAP_SIZE*2)-MAP_SIZE; if(Math.hypot(x, y)>300) walls.push({x, y, w:80, h:80}); }
}

function startGame(mode) {
    gameMode = mode; level = 1; enemiesKilled = 0; score = 0; arcadeWave = 1;
    player = new Player(); enemies = []; projectiles = []; friends = []; pickups = []; floatingTexts = []; particles = [];
    boss = null; generateMap(); AudioSys.init(); AudioSys.playBGM(false);
    
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('level-select-screen').classList.add('hidden');
    document.getElementById('victory-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('boss-hp-container').style.display = 'none';
    
    if(gameMode === 'STORY') loadLevel(1);
    else { gameState = 'PLAY'; document.getElementById('location-text').innerText = "ARCADE"; document.getElementById('objective-text').innerText = "SURVIVE"; }
    lastTime = performance.now(); requestAnimationFrame(gameLoop);
}

function startLevel(lvl) {
    startGame('STORY');
    loadLevel(lvl);
}

function loadLevel(lvl) {
    level = lvl; enemies = []; projectiles = []; pickups = []; player.x = 0; player.y = 0; generateMap();
    if(lvl === 1) {
        document.getElementById('location-text').innerText = "MUNICH"; document.getElementById('objective-text').innerText = "Kill 20 Wobbuffets";
        friends = [new Friend('Bakshi', 'üêµ', 100, 100)];
        queueDialogue('BAKSHI', "Ooh ooh ah ah! I'm going monkey mode.");
        queueDialogue('CONNERY', "Bakshi, why are they wobbling?");
        queueDialogue('BAKSHI', "Just throw the bananas Connery! They are weak to potassium!");
    } else if (lvl === 2) {
        document.getElementById('location-text').innerText = "TRAIN"; document.getElementById('objective-text').innerText = "Kill 25 Enemies";
        friends = [new Friend('Rishi', 'üßÄ', 100, 50)]; queueDialogue('RISHI', "These guys are dog water. 0 PR.");
        queueDialogue('RISHI', "Bro, I'm literally box fighting a ticket inspector rn.");
        queueDialogue('RISHI', "They're lost in the sauce. Full piece them.");
    } else if (lvl === 3) {
        document.getElementById('location-text').innerText = "HOSPITAL"; document.getElementById('objective-text').innerText = "Survive Allergy";
        friends = [new Friend('Samir', 'üíÖ', -50, 50), new Friend('Ibby', 'üí™', 50, 50), new Friend('Sean', 'üíª', 0, 100)];
        queueDialogue('IBBY', "My pre-workout just kicked in. Let's go!");
        queueDialogue('SAMIR', "My skin is breaking out!");
        queueDialogue('SAMIR', "Rawr xD... wait did I say that out loud?");
        queueDialogue('SEAN', "My shield damages them continuously!");
    } else if (lvl === 4) {
        document.getElementById('location-text').innerText = "PRAGUE NIGHT"; document.getElementById('objective-text').innerText = "Kill 30 Apples";
        friends = []; queueDialogue('CONNERY', "It's quiet. Too quiet."); queueDialogue('UNKNOWN', "The apples... they are smiling.");
        queueDialogue('CONNERY', "Why are they green?"); queueDialogue('UNKNOWN', "Beware the smiling apples...");
    } else if (lvl === 5) {
        document.getElementById('location-text').innerText = "THE END"; document.getElementById('objective-text').innerText = "DEFEAT DRAGON";
        document.getElementById('boss-hp-container').style.display = 'block';
        friends = [
            new Friend('Bakshi', 'üêµ', -100, 50), new Friend('Rishi', 'üßÄ', 100, 50),
            new Friend('Ibby', 'üí™', -50, 100), new Friend('Sean', 'üíª', 50, 100), new Friend('Samir', 'üíÖ', 0, 150)
        ];
        boss = new EnderDragon(); AudioSys.playBGM(true);
        bossIntroState = 1; bossIntroTimer = 0; cutsceneHuTao = { x: player.x + 30, y: player.y };
        queueDialogue('HU TAO', "Connery! Help me!"); queueDialogue('CONNERY', "Hu Tao!");
        queueDialogue('HU TAO', "Oya? Save me and I'll give you a discount on a coffin!");
        queueDialogue('IBBY', "That dragon skipped leg day. Easy wins.");
        queueDialogue('SEAN', "It's the Ender Dragon! He has 10k HP!");
        queueDialogue('CONNERY', "Not on my birthday.");
    } else if (lvl === 6) { startEndingSequence(); return; }
    gameState = 'PAUSE_DIALOGUE'; showNextDialogue();
}

function queueDialogue(name, text) { dialogueQueue.push({name, text}); }
function showNextDialogue() {
    if(dialogueQueue.length > 0) {
        const d = dialogueQueue.shift(); document.getElementById('dialogue-name').innerText = d.name; document.getElementById('dialogue-text').innerText = d.text;
        document.getElementById('dialogue-box').style.display = 'block';
    } else { document.getElementById('dialogue-box').style.display = 'none'; gameState = 'PLAY'; }
}
function advanceDialogue() { showNextDialogue(); }
function showPopup(text) { 
    const p = document.getElementById('popup-msg'); p.innerText = text; p.style.opacity = 1; setTimeout(() => p.style.opacity = 0, 3000); 
}

function checkWinCondition() {
    if(gameMode === 'ARCADE') { arcadeKills++; if(arcadeKills > arcadeWave * 15) gameState = 'UPGRADE'; return; }
    if (level === 5) return;
    const goals = [20, 25, 30, 30];
    document.getElementById('objective-text').innerText = `Kill: ${enemiesKilled}/${goals[level-1]}`;
    if(enemiesKilled >= goals[level-1]) { enemiesKilled = 0; loadLevel(level + 1); }
}

function applyUpgrade(type) {
    if(type === 'speed') player.speed += 50; if(type === 'damage') player.dmgMult += 0.5; if(type === 'heal') player.hp = 125;
    arcadeWave++; arcadeKills = 0; document.getElementById('wave-text').innerText = "WAVE " + arcadeWave; document.getElementById('upgrade-screen').classList.add('hidden'); gameState = 'PLAY';
}

function startEndingSequence() {
    level = 6; enemies = []; projectiles = []; boss = null;
    document.getElementById('boss-hp-container').style.display = 'none';
    AudioSys.playBGM(false);
    player.x = 0; player.y = 300;
    friends = [
        new Friend('Bakshi', 'üêµ', -100, 300), new Friend('Rishi', 'üßÄ', 100, 300),
        new Friend('Ibby', 'üí™', -150, 320), new Friend('Sean', 'üíª', 150, 320),
        new Friend('Samir', 'üíÖ', -50, 350), new Friend('Sebastian', 'üë®‚Äçü¶∞', 50, 350)
    ];
    queueDialogue('SEBASTIAN', "We did it! Let's go to the monument.");
    endingPhase = 1; gameState = 'PAUSE_DIALOGUE'; showNextDialogue();
}

function createParticle(x, y, color, count) {
    for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
}

function gameLoop(timestamp) {
    if(gameState === 'GAMEOVER') return;
    if(gameState === 'UPGRADE') { document.getElementById('upgrade-screen').classList.remove('hidden'); return; }
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1); lastTime = timestamp;
    requestAnimationFrame(gameLoop);
    if(gameState === 'PAUSE_DIALOGUE') return;

    timeElapsed += dt;

    player.update(dt, walls);
    friends.forEach(f => f.update(dt, enemies, player, friends));
    if(boss) boss.update(dt);
    if(enemies.length < (gameMode==='ARCADE'?5+arcadeWave*3:5+level*3) && Math.random() < 0.05) spawnEnemy();

    enemies.forEach(e => e.update(dt, player, walls));
    projectiles.forEach(p => {
        p.update(dt);
        if(!p.markedForDeletion) {
            if(boss && Math.hypot(p.x - boss.x, p.y - boss.y) < 100) {
                p.markedForDeletion = true; let dmg = p.type === 'DICE' ? p.roll * 8 * player.dmgMult : 10;
                boss.hp -= dmg; document.getElementById('boss-hp-fill').style.width = (boss.hp / boss.maxHp * 100) + '%';
                createParticle(p.x, p.y, '#a020f0', 3);
                if(boss.hp <= 0) { boss = null; loadLevel(6); }
            }
            enemies.forEach(e => {
                if(!e.markedForDeletion && e.type !== 'FIREBALL' && Math.hypot(p.x - e.x, p.y - e.y) < e.radius + 10) {
                    p.markedForDeletion = true;
                    let dmg = p.type === 'DICE' ? p.roll * 4 * player.dmgMult : (level === 1 ? 15 : 1000);
                    if(p.type === 'DICE' && p.roll === 6) { dmg *= 3; floatingTexts.push(new FloatingText(e.x, e.y, "CRIT!", "#f1c40f")); }
                    else { floatingTexts.push(new FloatingText(e.x, e.y, Math.floor(dmg), '#fff')); }
                    e.hp -= dmg; e.pushX += (e.x - p.x) * 2; e.pushY += (e.y - p.y) * 2;
                    AudioSys.sfxHit(); createParticle(e.x, e.y, '#fff', 2);
                    if(e.hp <= 0) killEnemy(e);
                }
            });
        }
    });

    // Sword & Player Hits
    const sx = player.x + Math.cos(player.swordAngle) * 70; const sy = player.y + Math.sin(player.swordAngle) * 70;
    enemies.forEach(e => {
        if(Math.hypot(sx - e.x, sy - e.y) < 30 && e.type !== 'FIREBALL') {
            e.hp -= 10 * player.dmgMult; floatingTexts.push(new FloatingText(e.x, e.y, Math.floor(10*player.dmgMult), '#0ff'));
            e.pushX = (e.x - player.x) * 3; e.pushY = (e.y - player.y) * 3;
            if(e.hp <= 0 && !e.markedForDeletion) killEnemy(e);
        }
        if(Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius) {
            player.hp -= e.damage; 
            if(e.type === 'CREEPER') { e.markedForDeletion = true; AudioSys.sfxExplode(); createParticle(player.x, player.y, '#f00', 10); player.hp -= 30; }
            if(e.type === 'FIREBALL') { e.markedForDeletion = true; player.hp -= 5; }
            document.getElementById('hp-fill').style.width = Math.max(0, player.hp/1.25) + '%';
            if(player.hp <= 0) { gameState = 'GAMEOVER'; document.getElementById('game-over-screen').classList.remove('hidden'); }
        }
    });

    pickups.forEach(p => {
        if(Math.hypot(player.x - p.x, player.y - p.y) < 30) {
            p.markedForDeletion = true; player.hp = Math.min(125, player.hp + 25);
            document.getElementById('hp-fill').style.width = Math.max(0, player.hp/1.25) + '%';
            floatingTexts.push(new FloatingText(player.x, player.y, "+HP", "#2ecc71")); AudioSys.sfxHeal();
        }
    });

    // Boss Intro Logic
    if(level === 5 && bossIntroState === 1 && boss) {
        bossIntroTimer += dt;
        let tx = boss.x + 100; let ty = boss.y;
        cutsceneHuTao.x += (tx - cutsceneHuTao.x) * 2 * dt;
        cutsceneHuTao.y += (ty - cutsceneHuTao.y) * 2 * dt;
        if(bossIntroTimer > 2) {
            bossIntroState = 2; cutsceneHuTao = null; 
        }
    }

    particles.forEach(p => p.update(dt));
    floatingTexts.forEach(t => t.update(dt));

    enemies = enemies.filter(e => !e.markedForDeletion); projectiles = projectiles.filter(p => !p.markedForDeletion);
    pickups = pickups.filter(p => !p.markedForDeletion); floatingTexts = floatingTexts.filter(t => t.life > 0);
    particles = particles.filter(p => p.life > 0);

    // DRAW
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const cx = -player.x + canvas.width/2; const cy = -player.y + canvas.height/2;
    ctx.save();
    
    // BG
    if(level === 1) ctx.fillStyle = '#1a1a2e'; else if(level === 2) ctx.fillStyle = '#2d3436';
    else if(level === 3) ctx.fillStyle = '#ecf0f1'; else if(level === 4) ctx.fillStyle = '#2c3e50';
    else if(level === 5) ctx.fillStyle = '#220022';
    else ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // Level 6 Sky BG
    if(level === 6) {
        let grad = ctx.createLinearGradient(0,0,0,canvas.height);
        grad.addColorStop(0, '#000033'); grad.addColorStop(1, '#660066');
        ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height);
    }

    ctx.translate(cx, cy);

    // Level 6 Camera Pan up
    if(level === 6 && endingPhase >= 2) {
        ctx.translate(0, 200 * Math.min(1, (endingTimer)/5)); // Pan up
    }

    const gridSize = 100;
    const startCol = Math.floor((player.x - canvas.width)/gridSize); const endCol = Math.floor((player.x + canvas.width)/gridSize);
    const startRow = Math.floor((player.y - canvas.height)/gridSize); const endRow = Math.floor((player.y + canvas.height)/gridSize);
    ctx.strokeStyle = (level === 3) ? '#bdc3c7' : '#333'; ctx.lineWidth = 2;
    for(let c=startCol; c<=endCol; c++) { for(let r=startRow; r<=endRow; r++) { ctx.strokeRect(c*gridSize, r*gridSize, gridSize, gridSize); } }

    if(gameMode === 'ARCADE' || level === 5) {
        let lim = level === 5 ? 900 : ARCADE_LIMIT; ctx.strokeStyle = 'red'; ctx.lineWidth = 5; ctx.strokeRect(-lim, -lim, lim*2, lim*2);
    }

    ctx.fillStyle = '#7f8c8d';
    walls.forEach(w => {
        if(w.x+w.w > player.x-canvas.width && w.x < player.x+canvas.width) {
            ctx.fillRect(w.x, w.y, w.w, w.h); ctx.fillStyle = '#555'; ctx.fillRect(w.x+10, w.y+10, w.w-20, w.h-20); ctx.fillStyle = '#7f8c8d';
        }
    });

    if(level === 6) {
        ctx.fillStyle = 'white'; ctx.fillRect(-40, -100, 80, 200); ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.arc(0, -60, 25, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.fillText('XII', -10, -55); ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(-50, -100); ctx.lineTo(50, -100); ctx.lineTo(0, -160); ctx.fill();
    }
    
    if(level === 5 && bossIntroState === 1 && cutsceneHuTao) {
        if(IMAGES.hutao.complete) ctx.drawImage(IMAGES.hutao, cutsceneHuTao.x-30, cutsceneHuTao.y-30, 60, 60);
    }
    
    if(level === 5 && boss && bossIntroState !== 1) {
        ctx.save(); ctx.translate(boss.x + 100, boss.y); // Hu Tao beside dragon in cage
        if(IMAGES.hutao.complete) { ctx.drawImage(IMAGES.hutao, -30, -30, 60, 60); }
        ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.strokeRect(-40, -40, 80, 80);
        ctx.restore();
    }

    pickups.forEach(p => p.draw(ctx)); friends.forEach(f => f.draw(ctx)); player.draw(ctx); enemies.forEach(e => e.draw(ctx));
    if(boss) boss.draw(ctx); projectiles.forEach(p => p.draw(ctx)); particles.forEach(p => p.draw(ctx)); floatingTexts.forEach(t => t.draw(ctx));
    ctx.restore();

    if(level === 4) {
        let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 100, canvas.width/2, canvas.height/2, 800);
        grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.95)'); ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height);
    }
    
    if(level === 6) {
        endingTimer += dt;
        if(endingPhase === 1) { 
             let atTarget = true;
             [player, ...friends].forEach(ent => {
                 let tx = ent === player ? 0 : ent.x * 0.9; let ty = ent === player ? 100 : 100 + (ent.x%50);
                 let dx = tx - ent.x; let dy = ty - ent.y;
                 if(Math.abs(dx) > 5 || Math.abs(dy) > 5) { ent.x += dx * dt; ent.y += dy * dt; atTarget = false; }
             });
             if(atTarget && endingTimer > 2) { endingPhase = 2; endingTimer = 0; }
        } else if (endingPhase === 2) { 
            // Celebration Text
            ctx.font = '30px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillStyle = `hsl(${Date.now()/5 % 360}, 100%, 50%)`;
            ctx.fillText("CELEBRATE!", canvas.width/2, 150);

            if(Math.random() < 0.1) { // Fireworks
                let fx = (Math.random()*800) - 400; // Relative to monument
                let fy = (Math.random()*400) - 600; 
                let col = getRandomColor();
                // Spawn particles in world space (relative to monument)
                // Actually need to translate these because they are drawn inside ctx.translate block in particle loop?
                // No, createParticle pushes to array which is drawn in world space.
                for(let i=0; i<30; i++) {
                    particles.push(new Particle(fx, fy, col, 2));
                }
                AudioSys.sfxThrow();
            }
            if(endingTimer > 8) { endingPhase = 3; endingTimer = 0; }
        } else if (endingPhase === 3) { 
            ctx.fillStyle = 'rgba(255,192,203, 0.5)'; ctx.fillRect(0,0,canvas.width, canvas.height);
            let cx = canvas.width/2; let cy = canvas.height/2;
            if(IMAGES.kiss.complete) { let w = 400; let h = 300; ctx.drawImage(IMAGES.kiss, cx - w/2, cy - h/2, w, h); }
            ctx.fillStyle = 'white'; ctx.font = '20px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText("Happy Birthday!", cx, cy + 200);
            if(endingTimer > 5) { document.getElementById('victory-screen').classList.remove('hidden'); endingPhase = 4; }
        }
    }
}

function getRandomColor() { return ['#f00','#0f0','#00f','#ff0','#0ff','#f0f'][Math.floor(Math.random()*6)]; }
function createParticle(x, y, color, count) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }
function killEnemy(e) {
    e.markedForDeletion = true; enemiesKilled++; score += 100; document.getElementById('score').innerText = "SCORE: " + score;
    checkWinCondition(); if(Math.random() > 0.8) pickups.push(new Pickup(e.x, e.y));
    if(e.type === 'APPLE' || e.type === 'CREEPER') {
        AudioSys.sfxExplode(); createParticle(e.x, e.y, '#f00', 10);
        enemies.forEach(other => { if(other !== e && Math.hypot(e.x - other.x, e.y - other.y) < 150) { other.hp -= 20; other.pushX += (other.x - e.x)*3; other.pushY += (other.y - e.y)*3; } });
    }
}
</script>
</body>
</html>
